#type $RodataReader {
    address: $u64,
    end_address: $u64,
}

// Expects newline-character-separated lines of byte-data
#type $RodataReader2D {
    address: $u64,
    width: $u64,
    height: $u64,
}

#type $ParseNumber {
    number: $u64,
    index: $u64,
    address: $u64,
}
// Parse a decimal number from a string at the given address tarting at the given index.
// Will return the number and the index after the number in the returned type
// Stack before:
//   $ParseNumber
// Stack after:
//   $ParseNumber
#proc parse_number_dec {
.loop:
    // get input byte
    dup
    #get $ParseNumber.address
    pick 1
    #get $ParseNumber.index
    plus
    deref_size 1
    // check if it is a digit
    dup
    constu '0'
    lt
    bra .end_drop
    dup
    constu '9'
    gt
    bra .end_drop
    // get actual number
    constu '0'
    minus
    pick 1
    #get $ParseNumber.number
    constu 10
    mul
    plus
    #set $ParseNumber.number

    // increase index
    dup
    #get $ParseNumber.index
    constu 1
    plus
    #set $ParseNumber.index
    skip .loop
.end_drop:
    drop
.end:
}

// Create a new $RodataReader
// Stack before:
//     addr, addr_of_len
// Stack after:
//     $RodataReader
#proc rodata_reader_new {
    #create $RodataReader {
        address: 0,
        end_address: 0,
    } // -> addr, addr_of_len, $RodataReader
    pick 2 // -> addr, addr_of_len, $RodataReader, addr
    #set $RodataReader.address
    rot // -> $RodataReader, addr, addr_of_len
    deref
    plus
    #set $RodataReader.end_address
}

// Check if the $RodataReader is at its end.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader, bool
#proc rodata_reader_is_eof {
    dup
    #get $RodataReader.address
    pick 1
    #get $RodataReader.end_address
    ge
}

// Read a single char.
// Panics if the reader reached the end.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader, char
#proc rodata_reader_read_char {
    #if (call rodata_reader_is_eof) == (constu 1) {
        constu 910823749081723
        call panic
    }

    dup
    #get $RodataReader.address
    deref_size 1
    swap
    #set $RodataReader.address += 1
    swap
}

// Read a line into a $String, excluding the newline (but consuming it).
// Panics if the line has more than 254 bytes.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader, $String
#proc rodata_reader_read_line {
    constu 0 // -> $RodataReader, index
    #create $String {
        len: 0,
        data: [0; 254],
    } // -> $RodataReader, index, $String

    #while (
        rot, rot, // -> index, $String, $RodataReader
        call rodata_reader_read_char, // -> index, $String, $RodataReader, char
        dup
    ) != (constu '\n') {
        // -> index, $String, $RodataReader, char
        #if (pick 3) >= (constu 254) {
            constu 19782374091873
            call panic
        }

        swap // -> index, $String, char, $RodataReader
        rot // -> index, $RodataReader, $String, char
        pick 3 // -> index, $RodataReader, $String, char, index
        #setindex $String.data // -> index, $RodataReader, $String
        rot // -> $String, index, $RodataReader
        rot // -> $RodataReader, $String, index
        constu 1
        plus
        swap // -> $RodataReader, index, $String
    }
    drop
    rot // -> $RodataReader, index, $String
    swap // -> $RodataReader, $String, index
    #set $String.len // -> $RodataReader, $String
}

// Create a new $RodataReader2D
// Stack before:
//     addr, addr_of_len
// Stack after:
//     $RodataReader2D
#proc rodata_reader_2d_new {
    #create $RodataReader2D {
        address: 0,
        width: 0xffff_ffff_ffff_ffff,
        height: 0,
    } // -> addr, addr_of_len, $RodataReader2D
    pick 2
    #set $RodataReader2D.address
    rot // -> $RodataReader2D, addr, addr_of_len
    call rodata_reader_new // -> $RodataReader2D, $RodataReader

    constu 0
    swap // -> $RodataReader2D, width, $RodataReader

    #while (call rodata_reader_is_eof) != (constu 1) {
        call rodata_reader_read_char
        #if () != (constu '\n') {
            swap
            constu 1
            plus
            swap
        } #else {
            #if (pick 2, #get $RodataReader2D.width) == (consts -1) {
                // we haven't stored a width yet -> set it
                rot
                #set $RodataReader2D.width // -> $RodataReader, $RodataReader2D
                constu 0
                rot
                rot // -> $RodataReader2D, width, $RodataReader
            } #else #if (pick 2, #get $RodataReader2D.width) == (pick 2) {
                // width is same as all previous rows -> reset width to 0
                rot
                drop
                constu 0
                rot
                rot
            } #else #if (pick 1) == (constu 0) {
                // line is empty -> ignore -> reset width to 0; continue
                rot
                drop
                constu 0
                rot
                rot
                skip .continue
            } #else {
                // width of current line differs from previous lines -> panic
                drop
                swap // -> current_width, $RodataReader2D
                dup
                #get $RodataReader2D.width
                swap
                #get $RodataReader2D.height
                constu 89024987344987
                // -> current_width, previous_width, current_height
                call panic
            }
            // increase height
            rot
            rot
            #set $RodataReader2D.height += 1
            rot
        }
        .continue:
    }
    // -> $RodataReader2D, width, $RodataReader
    // check last line
    #if (pick 2, #get $RodataReader2D.width) == (pick 2) {
        // width is same as all previous rows -> increase height
        drop
        drop
        #set $RodataReader2D.height += 1
    } #else #if (pick 1) == (constu 0) {
        // line is empty -> ignore
        drop
        drop
    } #else {
        constu 2034927802904387
        drop
        swap
        dup
        #get $RodataReader2D.width
        swap
        #get $RodataReader2D.height
        // -> current_width, previous_width, current_height
        call panic
    }
}

// Returns a single byte at the given position, or the default value if `x`
// or `y` is out of bounds
// Stack before:
//     $RodataReader2D, x, y, default
// Stack after:
//     $RodataReader2D, value
#proc rodata_reader_2d_get_default {
    #if (pick 3, #get $RodataReader2D.width) <= (pick 3) {
        rot
        drop
        drop
    } #else #if (pick 2) < (constu 0) {
        rot
        drop
        drop
    } #else #if (pick 3, #get $RodataReader2D.height) <= (pick 2) {
        rot
        drop
        drop
    } #else #if (pick 1) < (constu 0) {
        rot
        drop
        drop
    } #else {
        drop // -> $RodataReader2D, x, y
        pick 2
        #get $RodataReader2D.width
        constu 1
        plus // add newline character to width
        mul // -> $RodataReader2D, x, width*y
        plus // -> $RodataReader2D, x + width*y
        pick 1
        #get $RodataReader2D.address
        plus // -> $RodataReader2D, addr + x + width*y
        deref_size 1
    }
}

// Returns a single byte at the given position, or the default value if `x`
// or `y` is out of bounds
// Stack before:
//     $RodataReader2D, x, y
// Stack after:
//     $RodataReader2D, value
#proc rodata_reader_2d_get {
    constu 0xdead
    call rodata_reader_2d_get_default
    #if (dup) == (constu 0xdead) {
        constu 9207348795298
        call panic
    }
}
