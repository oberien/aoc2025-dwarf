#type $RodataReader {
    address: $u64,
    end_address: $u64,
}

// Expects newline-character-separated lines of byte-data
#type $RodataReader2D {
    address: $u64,
    width: $u64,
    height: $u64,
}

#type $ParseNumber {
    number: $u64,
    index: $u64,
    address: $u64,
}
// Parse a decimal number from a string at the given address tarting at the given index.
// Will return the number and the index after the number in the returned type
// Stack before:
//   $ParseNumber
// Stack after:
//   $ParseNumber
#proc parse_number_dec {
.loop:
    // get input byte
    dup
    #get $ParseNumber.address
    pick 1
    #get $ParseNumber.index
    plus
    deref_size 1
    // check if it is a digit
    dup
    constu '0'
    lt
    bra .end_drop
    dup
    constu '9'
    gt
    bra .end_drop
    // get actual number
    constu '0'
    minus
    pick 1
    #get $ParseNumber.number
    constu 10
    mul
    plus
    #set $ParseNumber.number

    // increase index
    dup
    #get $ParseNumber.index
    constu 1
    plus
    #set $ParseNumber.index
    skip .loop
.end_drop:
    drop
.end:
}

// Create a new $RodataReader
// Stack before:
//     addr, addr_of_len
// Stack after:
//     $RodataReader
#proc rodata_reader_new {
    #create $RodataReader {
        address: 0,
        end_address: 0,
    } // -> addr, addr_of_len, $RodataReader
    pick 2 // -> addr, addr_of_len, $RodataReader, addr
    #set $RodataReader.address
    rot // -> $RodataReader, addr, addr_of_len
    deref
    plus
    #set $RodataReader.end_address
}

// Check if the $RodataReader is at its end.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader, bool
#proc rodata_reader_is_eof {
    dup
    #get $RodataReader.address
    pick 1
    #get $RodataReader.end_address
    ge
}

// Read a single char, return -1 if eof
// Panics if the reader reached the end.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader, char
#proc rodata_reader_try_read_char {
    #if (call rodata_reader_is_eof) == (constu 1) {
        consts -1
        skip .end
    }

    dup
    #get $RodataReader.address
    deref_size 1
    swap
    #set $RodataReader.address += 1
    swap
.end:
}
// Read a single char, panicking on eof.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader, char
#proc rodata_reader_read_char {
    call rodata_reader_try_read_char
    #if (dup) == (consts -1) {
        constu 910823749081723
        call panic
    }
}

// Read a line into a $String, excluding the newline (but consuming it).
// Panics if the line has more than 254 bytes.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader, $String
#proc rodata_reader_read_line {
    constu 0 // -> $RodataReader, index
    #create $String {
        len: 0,
        data: [0; 254],
    } // -> $RodataReader, index, $String

    #while (
        rot, rot, // -> index, $String, $RodataReader
        call rodata_reader_read_char, // -> index, $String, $RodataReader, char
        dup
    ) != (constu '\n') {
        // -> index, $String, $RodataReader, char
        #if (pick 3) >= (constu 254) {
            constu 19782374091873
            call panic
        }

        swap // -> index, $String, char, $RodataReader
        rot // -> index, $RodataReader, $String, char
        pick 3 // -> index, $RodataReader, $String, char, index
        #setindex $String.data // -> index, $RodataReader, $String
        rot // -> $String, index, $RodataReader
        rot // -> $RodataReader, $String, index
        constu 1
        plus
        swap // -> $RodataReader, index, $String
    }
    drop
    rot // -> $RodataReader, index, $String
    swap // -> $RodataReader, $String, index
    #set $String.len // -> $RodataReader, $String
}

// Skip everything until including a double-newline "\n\n" or eof.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader
#proc rodata_reader_skip_to_double_newline {
    consts 0
    consts 0 // -> $RodataReader, last, current
    #while (dup) != (constu '\n') or (pick 2) != (constu '\n') {
        swap
        drop // -> $RodataReader, current
        swap
        call rodata_reader_try_read_char // -> current, $RodataReader, new
        #if (dup) == (consts -1) {
            skip .end
        }
        swap
        rot // -> $RodataReader, current, new
    }
.end:
    drop
    drop
}

// Try to read a number, returning -1 if the reader doesn't start with a valid digit
// (doesn't consume any chars in the error case).
// Panicks if called on eof.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader, number
#proc rodata_reader_try_read_number {
    call rodata_reader_read_char // -> $RodataReader, char
    #if (dup) < (constu '0') {
        skip .error
    }
    #if (dup) > (constu '9') {
        skip .error
    }
    drop
    // unconsume char
    #set $RodataReader.address -= 1


    // we start with a digit -> parse
    constu 0 // -> $RodataReader, value
    #while (swap, call rodata_reader_try_read_char, dup) >= (constu '0') and (pick 1) <= (constu '9') {
        // -> value, $RodataReader, char
        constu '0'
        minus
        rot
        rot // -> $RodataReader, char, value
        constu 10
        mul
        plus // -> $RodataReader, value
    }
    // -> value, $RodataReader, char
    #if (dup) == (consts -1) {
        // un-unconsume last char as it is a digit
        swap
        #set $RodataReader.address += 1
        swap
    }
    drop
    swap
    skip .end
.error:
     // -> $RodataReader, char
     drop
     consts -1
.end:
    // unconsume the last non-digit char
    swap
    #set $RodataReader.address -= 1
    swap
}

// Consumes chars until it finds a non-whitespace or eof.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader
#proc rodata_reader_skip_whitespace {
    #while (call rodata_reader_try_read_char, dup) != (consts -1) {
        #if (dup) != (constu ' ') and (pick 1) != (constu '\t') and (pick 2) != (constu '\n') and (pick 3) != (constu '\r') {
            skip .end
        }
        drop
    }
.end:
    // unconsume non-whitespace char if non-eof was reached
    #if () != (consts -1) {
        #set $RodataReader.address -= 1
    }
}

// Consumes chars until it finds a non-whitespace and returns it, or -1 on eof.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader, char
#proc rodata_reader_next_non_whitespace_char {
    call rodata_reader_skip_whitespace
    call rodata_reader_try_read_char
}

// Consumes chars until it finds a number and returns the number, or -1 on eof.
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader, number
#proc rodata_reader_next_number {
.loop:
    #if (call rodata_reader_is_eof) == (constu 1) {
        consts -1
        skip .end
    }
    call rodata_reader_try_read_number
    #if (dup) != (consts -1) {
        skip .end
    }
    drop
    call rodata_reader_read_char
    drop

    skip .loop
.end:
}

// Progresses the reader to just before the occurrence of the provided char, returning
// -1 if eof was reached (0 otherwise)
// Stack before:
//     $RodataReader, char
// Stack after:
//     $RodataReader, result
#proc rodata_reader_go_to_char {
    swap // -> needle, $RodataReader
.loop:
    call rodata_reader_try_read_char // -> needle, $RodataReader, char
    #if (dup) == (consts -1) {
        drop
        swap
        drop
        consts -1
        skip .end
    }
    #if (dup) == (pick 3) {
        // found the needle; skip back to before it
        drop
        swap
        drop
        #set $RodataReader.address -= 1
        constu 0
        skip .end
    }
    drop

    skip .loop
.end:
}

// Progresses the reader to the start of the next line, returning
// -1 if eof was reached (0 otherwise)
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader, result
#proc rodata_reader_go_to_next_line {
    constu '\n'
    call rodata_reader_go_to_char
    #if (dup) == (consts -1) {
        skip .end
    }
    drop
    #set $RodataReader.address += 1
    constu 0
.end:
}

// Progresses the reader to the start of the last line
// Stack before:
//     $RodataReader
// Stack after:
//     $RodataReader
#proc rodata_reader_go_to_last_line {
    #while (dup, call rodata_reader_go_to_next_line) != (consts -1) {
        swap
        drop
    }
    drop
}

// Create a new $RodataReader2D
// Stack before:
//     addr, addr_of_len
// Stack after:
//     $RodataReader2D
#proc rodata_reader_2d_new {
    #create $RodataReader2D {
        address: 0,
        width: 0xffff_ffff_ffff_ffff,
        height: 0,
    } // -> addr, addr_of_len, $RodataReader2D
    pick 2
    #set $RodataReader2D.address
    rot // -> $RodataReader2D, addr, addr_of_len
    call rodata_reader_new // -> $RodataReader2D, $RodataReader

    constu 0
    swap // -> $RodataReader2D, width, $RodataReader

    #while (call rodata_reader_is_eof) != (constu 1) {
        call rodata_reader_read_char
        #if () != (constu '\n') {
            swap
            constu 1
            plus
            swap
        } #else {
            #if (pick 2, #get $RodataReader2D.width) == (consts -1) {
                // we haven't stored a width yet -> set it
                rot
                #set $RodataReader2D.width // -> $RodataReader, $RodataReader2D
                constu 0
                rot
                rot // -> $RodataReader2D, width, $RodataReader
            } #else #if (pick 2, #get $RodataReader2D.width) == (pick 2) {
                // width is same as all previous rows -> reset width to 0
                rot
                drop
                constu 0
                rot
                rot
            } #else {
                // width of current line differs from previous lines -> panic
                drop
                swap // -> current_width, $RodataReader2D
                dup
                #get $RodataReader2D.width
                swap
                #get $RodataReader2D.height
                constu 89024987344987
                // -> current_width, previous_width, current_height
                call panic
            }
            // increase height
            rot
            rot
            #set $RodataReader2D.height += 1
            rot
        }
        .continue:
    }
    // -> $RodataReader2D, width, $RodataReader
    // check last line
    #if (pick 2, #get $RodataReader2D.width) == (pick 2) {
        // width is same as all previous rows -> increase height
        drop
        drop
        #set $RodataReader2D.height += 1
    } #else #if (pick 1) == (constu 0) {
        // line is empty -> ignore
        drop
        drop
    } #else {
        constu 2034927802904387
        drop
        swap
        dup
        #get $RodataReader2D.width
        swap
        #get $RodataReader2D.height
        // -> current_width, previous_width, current_height
        call panic
    }
}

// Return a reader starting at the given x and y
// If x is larger than the width, the reader will be at the end of line y.
// If y is larger than the height, the reader will be at the end of the input.
// Stack before:
//     $RodataReader2D, x, y
// Stack after:
//     $RodataReader2D, $RodataReader
#proc rodata_reader_2d_get_reader_at {
    #if (pick 2, #get $RodataReader2D.width) <= (pick 2) {
        swap // -> $RodataReader2D, y, x
        drop // -> $RodataReader2D, y
        pick 1
        #get $RodataReader2D.width
        swap // -> $RodataReader2D, width, y
    } #else #if (pick 1) < (constu 0) {
        constu 72980498240389
        call panic
    }
    #if (pick 2, #get $RodataReader2D.height) <= (pick 1) {
        drop // -> $RodataReader2D, x
        drop // -> $RodataReader2D
        constu 0 // -> $RodataReader2D, x=0
        pick 1
        #get $RodataReader2D.height // -> $RodataReader2D, x=0, height
    } #else #if (dup) < (constu 0) {
        constu 439287427894327
        call panic
    }

    // -> $RodataReader2D, x, y
    pick 2
    #get $RodataReader2D.width
    constu 1
    plus // add newline character to width
    mul // -> $RodataReader2D, x, width*y
    plus // -> $RodataReader2D, x + width*y
    pick 1
    #get $RodataReader2D.address
    plus // -> $RodataReader2D, addr + x + width*y
    // get end_address
    pick 1
    #get $RodataReader2D.height // -> $RodataReader2D, addr, height
    pick 2
    #get $RodataReader2D.width // -> $RodataReader2D, addr, height, width
    constu 1
    plus
    mul // -> $RodataReader2D, addr, length
    pick 2
    #get $RodataReader2D.address
    plus // -> $RodataReader2D, addr, end_addr
    #create $RodataReader {
        address: 0,
        end_address: 0,
    }
    swap
    #set $RodataReader.end_address
    swap
    #set $RodataReader.address
}

// Returns a single byte at the given position, or the default value if `x`
// or `y` is out of bounds
// Stack before:
//     $RodataReader2D, x, y, default
// Stack after:
//     $RodataReader2D, value
#proc rodata_reader_2d_get_default {
    rot // -> $RodataReader2D, default, x, y
    pick 3
    rot // -> $RodataReader2D, default, $RodataReader2D, x, y
    call rodata_reader_2d_get_reader_at // -> $RodataReader2D, default, $RodataReader2D, $RodataReader
    call rodata_reader_try_read_char // -> $RodataReader2D, default, $RodataReader2D, $RodataReader, char
    #if (dup) == (consts -1) {
        drop
        drop
        drop
    } #else {
        rot
        drop
        drop // -> $RodataReader2D, default, char
        swap
        drop
    }
}

// Returns a single byte at the given position, or the default value if `x`
// or `y` is out of bounds
// Stack before:
//     $RodataReader2D, x, y
// Stack after:
//     $RodataReader2D, value
#proc rodata_reader_2d_get {
    constu 0xdead
    call rodata_reader_2d_get_default
    #if (dup) == (constu 0xdead) {
        constu 9207348795298
        call panic
    }
}

// Read a number in the column (from top to bottom), returning -1 if none was found or eof reached.
// Stack before:
//     $RodataReader2D, x, y
// Stack after:
//     $RodataReader2D, number
#proc rodata_reader_2d_next_number_vertical {
    consts -1 // -> $RodataReader2D, x, y, number
.loop:
    pick 3
    pick 3
    pick 3
    consts -1
    call rodata_reader_2d_get_default // -> $RodataReader2D, x, y, number, $RodataReader2D, char
    swap
    drop // -> $RodataReader2D, x, y, number, char
    #if (dup) == (consts -1) {
        // eof reached
        drop
        rot
        drop
        drop
        skip .end
    }
    #if (dup) < (constu '0') or (pick 1) > (constu '9') {
        // if we already read a number: go to end
        #if (pick 1) != (consts -1) {
            drop
            rot
            drop
            drop
            skip .end
        }
        // if we haven't found a number yet: continue
        drop
        skip .continue
    }
    // if we actually have a number, replace -1 with 0 before adding
    #if (pick 1) == (consts -1) {
        swap
        drop
        constu 0
        swap
    }
    constu '0'
    minus // -> $RodataReader, x, y, number, digit
    swap
    constu 10
    mul
    plus // -> $RodataReader, x, y, number

    .continue:
    swap
    constu 1
    plus
    swap
    skip .loop

.end:
}
