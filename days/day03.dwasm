#rodata day3_sample {
    #include_file "days/inputs/day03_sample"
}
#macro_if_file_exists "days/inputs/day03_input"
#rodata day3_input {
    #include_file "days/inputs/day03_input"
}
#macro_end_if_file_exists

#type $Day3 {
    reader: $RodataReader,
    num_digits: $u64,
    num_digits_left: $u64,
    sum: $u64,
}

#var day3_part1_sample {
    addr day3_sample
    addr day3_sample.len
    call rodata_reader_new
    constu 2
    call day3
    #get $Day3.sum
}
#var day3_part2_sample {
    addr day3_sample
    addr day3_sample.len
    call rodata_reader_new
    constu 12
    call day3
    #get $Day3.sum
}
#macro_if_file_exists "days/inputs/day03_input"
#var day3_part1 {
    addr day3_input
    addr day3_input.len
    call rodata_reader_new
    constu 2
    call day3
    #get $Day3.sum
}
#var day3_part2 {
    addr day3_input
    addr day3_input.len
    call rodata_reader_new
    constu 12
    call day3
    #get $Day3.sum
}
#macro_end_if_file_exists

// Stack before:
//   $RodataReader, num_digits
#proc day3 {
    dup
    #create $Day3 {
        reader: $RodataReader {
            address: 0,
            end_address: 0,
        },
        num_digits: 0,
        num_digits_left: 0,
        sum: 0,
    }
    swap
    #set $Day3.num_digits
    swap
    #set $Day3.num_digits_left
    swap
    #set $Day3.reader // -> $Day3

    #while (dup, #get $Day3.reader, call rodata_reader_is_eof) != (constu 1) {
        // get line
        call rodata_reader_read_line // -> $Day3, $RodataReader, $String
        rot
        #set $Day3.reader // -> $String, $Day3
        // reset num_digits_left
        dup
        #get $Day3.num_digits
        #set $Day3.num_digits_left
        swap // -> $Day3, $String

        #while (pick 1, #get $Day3.num_digits_left) > (constu 0) {
            pick 1
            #get $Day3.num_digits_left // -> $Day3, $String, num_digits_left
            call day3_single_step // -> $Day3, $String(left), scaled_number
            pick 2
            #get $Day3.sum
            plus // -> $Day3, $String, sum
            swap
            rot // -> $String, $Day3, sum
            #set $Day3.sum

            #set $Day3.num_digits_left -= 1
            swap // -> $Day3, $String
        }
        drop
    }
    drop
}

// Extracts the next number from the given slice, assuming the given
// number of digits are required
// Stack before:
//     $String(slice-left), num_digits_left
// Stack after:
//     $String(slice-left-after), scaled_number
#proc day3_single_step {
    // create string slice to search max in
    pick 1
    #get $String.len // -> $String, num_digits_left, len
    pick 1
    constu 1
    minus // -> $String, num_digits_left, len, num_digits_left-1
    minus // -> $String, num_digits_left, end
    constu 0
    swap // -> $String, num_digits_left, 0, end
    pick 3
    rot // -> $String, num_digits_left, $String, 0, end
    call string_slice // -> $String, num_digits_left, slice

    // get max
    call bytearray_max // -> $String, num_digits_left, max
    dup // -> $String, num_digits_left, max, max
    pick 3 // -> $String, num_digits_left, max, max, $String
    swap
    call bytearray_index_of // -> $String, num_digits_left, max, index

    // get the number from the char
    swap // -> $String, num_digits_left, index, max
    constu 0x30
    minus
    // shift the digit to the correct position / scale it
    constu 10 // -> $String, num_digits_left, index, max, 10
    pick 3
    constu 1
    minus
    call pow // -> $String, num_digits_left, index, max, multiplier
    mul // -> $String, num_digits_left, index, scaled_max
    rot
    rot
    drop // -> $String, index, scaled_max

    // reduce the string to its rest after the index
    rot // -> scaled_max, $String, index
    constu 1
    plus
    pick 1
    #get $String.len // -> scaled_max, $String, index+1, len
    call string_slice
    swap
}
