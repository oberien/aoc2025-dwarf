#rodata day6_sample {
    #include_file "days/inputs/day06_sample"
}
#rodata day6_input {
    #include_file "days/inputs/day06_input"
}

#type $Day6 {
        reader: $RodataReader2D,
        last_line_reader: $RodataReader,
        last_line_start: $u64,
        current_op: $u8,
        current_num: $u64,
        sum: $u64,
        part12: $u8,
}

#type $Day6xy {
    x: $u64,
    y: $u64,
}

#var day6_part1_sample {
    addr day6_sample
    addr day6_sample.len
    constu 1
    call day6
    #get $Day6.sum
}
#var day6_part1 {
    addr day6_input
    addr day6_input.len
    constu 1
    call day6
    #get $Day6.sum
}
#var day6_part2_sample {
    addr day6_sample
    addr day6_sample.len
    constu 2
    call day6
    #get $Day6.sum
}
#var day6_part2 {
    addr day6_input
    addr day6_input.len
    constu 2
    call day6
    #get $Day6.sum
}

// In the input, in the last line, the operator is always in the first
// character-column of a number-column. Thus, we have one reader in the last
// column to read the next non-whitespace-char, and one Reader2D to read the
// numbers at that x for each line except the last.
//
// Stack before:
//   input_addr, input_len_addr, part12
#proc day6 {
    #create $Day6 {
        reader: $RodataReader2D {
            address: 0,
            width: 0,
            height: 0,
        },
        last_line_reader: $RodataReader {
            address: 0,
            end_address: 0,
        },
        last_line_start: 0,
        current_op: 0,
        current_num: 0,
        sum: 0,
        part12: 0,
    } // -> input_addr, input_len_addr, part12, $Day6
    swap
    #set $Day6.part12 // -> input_addr, input_len_addr, $Day6

    pick 2
    pick 2
    call rodata_reader_new // -> input_addr, input_len_addr, $Day6, $RodataReader
    call rodata_reader_go_to_last_line
    dup
    rot // -> input_addr, input_len_addr, $RodataReader, $Day6, $RodataReader
    #get $RodataReader.address
    #set $Day6.last_line_start
    swap
    #set $Day6.last_line_reader // -> input_addr, input_len_addr, $Day6
    rot // -> $Day6, input_addr, input_len_addr
    call rodata_reader_2d_new // -> $Day6, $RodataReader2D
    #set $Day6.reader

    // -> $Day6

    #while (dup, #get $Day6.last_line_reader, call rodata_reader_next_non_whitespace_char, dup) != (consts -1) {
        // -> $Day6, $RodataReader, char
        rot
        #set $Day6.last_line_reader
        swap // -> $Day6, char
        dup
        rot // -> char, $Day6, char
        #set $Day6.current_op
        swap // -> $Day6, char
        #if (dup) == (constu '+') {
            drop
            #set $Day6.current_num = 0
        } #else #if (dup) == (constu '*') {
            drop
            #set $Day6.current_num = 1
        } #else {
            constu 19238795289
            call panic
        }
        // -> $Day6

        #create $Day6xy { x: 0, y: 0 }

        // get offset of the op in the last line
        pick 1
        #get $Day6.last_line_reader.address
        // subtract the current_op character
        constu 1
        minus // -> $Day6, address
        pick 2
        #get $Day6.last_line_start
        minus
        #set $Day6xy.x // -> $Day6, $Day6xy

        .loop:
            pick 1
            #get $Day6.part12
            #if () == (constu 1) {
                call day6_next_number_part1
            } #else {
                call day6_next_number_part2
            }
            // -> $Day6, $Day6xy, number
            #if (dup) == (consts -1) {
                drop
                skip .endloop
            }

            pick 2
            #get $Day6.current_num // -> $Day6, $Day6xy, number, current_num
            pick 3
            #get $Day6.current_op // -> $Day6, $Day6xy, number, current_num, op
            #if (dup) == (constu '+') {
                drop
                plus
            } #else #if (dup) == (constu '*') {
                drop
                mul
            } #else {
                // unreachable
                constu 947832549783438792
                call panic
            }
            // -> $Day6, $Day6xy, current_num
            swap // -> $Day6, current_num, $Day6xy
            rot // -> $Day6xy, $Day6, current_num
            #set $Day6.current_num
            swap // -> $Day6, $Day6xy
            skip .loop
        .endloop:

        // -> $Day6, $Day6xy
        drop // -> $Day6
        dup
        #get $Day6.sum
        pick 1
        #get $Day6.current_num
        plus
        #set $Day6.sum
    }
    drop
    drop
}

// Read and return the next number for Part1, returning -1 if no further number exists,
// updating $Day6xy in the process
//
// Stack before:
//     $Day6, $Day6xy
// Stack after:
//     $Day6, $Day6xy(updated), number
#proc day6_next_number_part1 {
    #if (dup, #get $Day6xy.y) >= (pick 2, #get $Day6.reader.height, constu 1, minus) {
        consts -1
        skip .end
    }

    pick 1
    #get $Day6.reader // -> $Day6, $Day6xy, $RodataReader2D
    pick 1
    #get $Day6xy.x // -> $Day6, $Day6xy, $RodataReader2D, x
    pick 2
    #get $Day6xy.y // -> $Day6, $Day6xy, $RodataReader2D, x, y
    call rodata_reader_2d_get_reader_at
    call rodata_reader_next_number // -> $Day6, $Day6xy, $RodataReader2D, $RodataReader, number
    rot // -> $Day6, $Day6xy, number, $RodataReader2D, $RodataReader
    drop
    drop // -> $Day6, $Day6xy, number

    swap
    #set $Day6xy.y += 1
    swap
.end:
}

// Read and return the next number for Part2, returning -1 if no further number exists,
// updating $Day6xy in the process
//
// Stack before:
//     $Day6, $Day6xy
// Stack after:
//     $Day6, $Day6xy(updated), number
#proc day6_next_number_part2 {

}
