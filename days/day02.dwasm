#rodata day2_sample {
    #include_file "days/inputs/day02_sample"
}
#rodata day2_input {
    #include_file "days/inputs/day02_input"
}

#type $Day2 {
    len: $u64,
    address: $u64,
    index: $u64,
    range_from: $u64,
    range_to: $u64,
    sum: $u64,
}

#var day2_part1_sample {
    addr day2_sample
    addr day2_sample.len
    deref
    call day2
    #get $Day2.sum
}
#var day2_part1 {
    addr day2_input
    addr day2_input.len
    deref
    call day2
    #get $Day2.sum
}
#var day2_part2_sample {
    addr day2_sample
    addr day2_sample.len
    deref
    call day2
    #get $Day2.sum
}
#var day2_part2 {
    addr day2_input
    addr day2_input.len
    deref
    call day2
    #get $Day2.sum
}

// Stack before:
//   input_addr, input_len
#proc day2 {
    #create $Day2 {
        len: 0,
        address: 0,
        index: 0,
        range_from: 0,
        range_to: 0,
        sum: 0,
    }
    swap
    #set $Day2.len
    swap
    #set $Day2.address

.loop:
    // parse first number
    #create $ParseNumber { number: 0, index: 0, address: 0 }
    pick 1
    #get $Day2.address
    #set $ParseNumber.address
    pick 1
    #get $Day2.index
    #set $ParseNumber.index
    call parse_number_dec
    swap // -> $ParseNumber, $Day2
    pick 1
    #get $ParseNumber.index
    #set $Day2.index
    pick 1
    #get $ParseNumber.number
    #set $Day2.range_from
    swap
    drop

    // parse '-'
    dup
    #get $Day2.address
    pick 1
    #get $Day2.index
    plus
    #if (deref_size 1) != (constu '-') {
        constu 948651483512
        call panic
    }
    #set $Day2.index += 1

    // parse second number
    #create $ParseNumber { number: 0, index: 0, address: 0 }
    pick 1
    #get $Day2.address
    #set $ParseNumber.address
    pick 1
    #get $Day2.index
    #set $ParseNumber.index
    call parse_number_dec
    swap // -> $ParseNumber, $Day2
    pick 1
    #get $ParseNumber.index
    #set $Day2.index
    pick 1
    #get $ParseNumber.number
    #set $Day2.range_to
    swap
    drop

    // iterate over all numbers in the range (inclusive end)
    #while (dup, #get $Day2.range_from) <= (pick 1, #get $Day2.range_to) {
        dup
        #get $Day2.range_from
        call string_from_number
        // split the string at the middle
        dup
        dup
        #get $String.len
        constu 2
        div // -> $Day2, $String, $String, half-len
        dup
        rot // -> $Day2, $String, half-len, $String, half-len
        constu 0
        swap // -> $Day2, $String, half-len, $String, 0, half-len
        call string_slice // -> $Day2, $String, half-len, first-half
        rot // -> $Day2, first-half, $String, half-len
        pick 1
        #get $String.len // -> $Day2, first-half, $String, half-len, len
        call string_slice // -> $Day2, first-half, second-half
        #if (nop) == (nop) {
            dup
            #get $Day2.range_from
            pick 1
            #get $Day2.sum
            plus
            #set $Day2.sum
        }

        #set $Day2.range_from += 1
    }


    // check if we reached end of input
    #if (dup, #get $Day2.index) >= (pick 1, #get $Day2.len) {
        skip .end
    }
    // parse ',' or '\n'
    dup
    #get $Day2.address
    pick 1
    #get $Day2.index
    plus
    deref_size 1
    #if (dup) == (constu '\n') {
        drop
        skip .end
    } #else #if (dup) == (constu ',') {
        // pass
    } #else {
        constu 4986157342
        call panic
    }
    drop
    #set $Day2.index += 1

    skip .loop
.end:
}
