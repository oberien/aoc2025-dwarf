#type $String {
    len: $u8,
    data: [$u8; 254],
}

#type $StringFromNumber {
    index: $u64,
    number: $u64,
}
// Stack before:
//   number
// Stack after:
//   $String
#proc string_from_number {
    #create $StringFromNumber {
        index: 0,
        number: 0,
    }
    swap
    #set $StringFromNumber.number
    dup
    #get $StringFromNumber.number
    call ilog10
    #set $StringFromNumber.index
    #create $String {
        len: 0,
        data: [0; 254],
    }
    pick 1
    #get $StringFromNumber.index
    #set $String.len
    swap // -> $String, $StringFromNumber
    #set $StringFromNumber.index -= 1
    #while (dup, #get $StringFromNumber.number) > (constu 0) {
        dup
        #get $StringFromNumber.number // -> $String, $StringFromNumber, number
        swap // -> $String, number, $StringFromNumber
        rot // -> $StringFromNumber, $String, number
        // get digit
        constu 10
        mod
        // make ascii-digit
        constu 0x30
        plus // -> $StringFromNumber, $String, ascii-digit
        pick 2
        #get $StringFromNumber.index // -> $StringFromNumber, $String, ascii-digit, index
        #setindex $String.data
        swap // -> $String, $StringFromNumber

        #set $StringFromNumber.number /= 10
        #set $StringFromNumber.index -= 1
    }
    drop
}

#type $StringSlice {
    from: $u64,
    to: $u64,
    index: $u64,
}
// Stack before:
//   $String, from (incl), to (excl)
// Stack after:
//   $String
#proc string_slice {
    // init work-struct
    #create $StringSlice {
        from: 0,
        to: 0,
        index: 0,
    }
    swap
    #set $StringSlice.to
    swap
    #set $StringSlice.from

    // init sliced string
    #create $String {
        len: 0,
        data: [0; 254],
    }
    pick 1
    #get $StringSlice.to
    pick 2
    #get $StringSlice.from
    minus
    #set $String.len
    swap

    // copy, -> $String(orig), $String(slice), $StringSlice
    #while (dup, #get $StringSlice.from) < (pick 1, #get $StringSlice.to) {
        dup
        #get $StringSlice.from // -> orig, slice, $StringSlice, index
        pick 3
        swap
        #getindex $String.data // -> orig, slice, $StringSlice, char
        swap
        rot // -> orig, $StringSlice, slice, char
        pick 2
        #get $StringSlice.index // -> orig, $StringSlice, slice, char, index
        #setindex $String.data
        swap // -> orig, slice, $StringSlice

        #set $StringSlice.from += 1
        #set $StringSlice.index += 1
    }
    drop // -> orig, slice
    swap // -> slice, orig
    drop // -> slice
}

// Splits a string at the given index.
// Returns [0..index), [index..len)
// Stack before:
//     $String, index
// Stack after:
//     $String(left), $String(right)
#proc string_split_at {
        pick 1 // -> $String, index, $String
        pick 1 // -> $String, index, $String, index
        constu 0
        swap // -> $String, index, $String, 0, index
        call string_slice // -> $String, index, $String(left)
        rot // -> $String(left), $String, index
        pick 1
        #get $String.len // -> $String(left), $String, index, len
        call string_slice // -> $String(left), $String(right)
}

// Repeat the given string n times
// Stack before:
//     $String, n
// Stack after:
//     $String
#proc string_repeat {
    // "ab".repeat(3) => "ababab" -> we need to append n-1 times
    constu 1
    minus
    pick 1
    #get $String.len // -> $String, n, orig_len
    rot // -> orig_len, $String, n
    #while (dup) > (constu 0) {
        swap // -> orig_len, n, $String
        constu 0 // -> orig_len, n, $String, index
        #while (dup) < (pick 4) {
            pick 1
            pick 1
            #getindex $String.data // -> orig_len, n, $String, index, char
            swap // -> orig_len, n, $String, char, index
            rot // -> orig_len, n, index, $String, char
            pick 2 // -> orig_len, n, index, $String, char, index
            pick 2
            #get $String.len // -> orig_len, n, index, $String, char, index, len
            plus // -> orig_len, n, index, $String, char, new_index
            #setindex $String.data // -> orig_len, n, index, $String
            swap // -> orig_len, n, $String, index
            constu 1
            plus
        }
        drop // -> orig_len, n, $String
        dup
        #get $String.len
        pick 3
        plus
        #set $String.len // -> orig_len, n, $String
        swap // -> orig_len, $String, n
        constu 1
        minus
    }
    drop
    swap
    drop
}
